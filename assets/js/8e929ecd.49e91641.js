"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[612],{3425:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"account_nonce","title":"Account nonce","description":"Subspace account nonce","source":"@site/docs/account_nonce.md","sourceDirName":".","slug":"/account_nonce","permalink":"/protocol-specs/docs/account_nonce","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Account nonce","hide_title":false,"sidebar_position":5,"description":"Subspace account nonce","keywords":["account","nonce"],"last_update":{"date":"03/07/2025","author":"Ning Lin"}},"sidebar":"tutorialSidebar","previous":{"title":"Permissioned Auto EVM","permalink":"/protocol-specs/docs/decex/permissioned_evm"},"next":{"title":"Fees and Rewards","permalink":"/protocol-specs/docs/category/fees-and-rewards"}}');var o=t(4848),c=t(8453);const i={title:"Account nonce",hide_title:!1,sidebar_position:5,description:"Subspace account nonce",keywords:["account","nonce"],last_update:{date:"03/07/2025",author:"Ning Lin"}},s=void 0,r={},l=[{value:"Account reap",id:"account-reap",level:2},{value:"Replay attack",id:"replay-attack",level:2},{value:"Default nonce for new account",id:"default-nonce-for-new-account",level:2},{value:"Compatibility",id:"compatibility",level:2}];function d(e){const n={a:"a",h2:"h2",p:"p",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"The nonce is an integer value in the account data. The nonce is attached to the transaction to be signed and is increased by one for every transaction that is included on-chain. A signed transaction that contains a nonce that doesn't match the nonce in the account data will be rejected to include on-chain, this essentially prevents replaying of a previous on-chain signed transaction."}),"\n",(0,o.jsx)(n.h2,{id:"account-reap",children:"Account reap"}),"\n",(0,o.jsxs)(n.p,{children:["Refer to ",(0,o.jsx)(n.a,{href:"https://wiki.polkadot.network/docs/learn-accounts#existential-deposit-and-reaping",children:"Existential Deposit and Reaping"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"replay-attack",children:"Replay attack"}),"\n",(0,o.jsxs)(n.p,{children:["Refer to ",(0,o.jsx)(n.a,{href:"https://wiki.polkadot.network/docs/transaction-attacks#replay-attack",children:"Replay Attack"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"In addition to the default nonce defence documented here, creating transactions with a short mortality interval also helps prevent replay attacks."}),"\n",(0,o.jsx)(n.h2,{id:"default-nonce-for-new-account",children:"Default nonce for new account"}),"\n",(0,o.jsx)(n.p,{children:"To futher mitigate the potential replay attack for mortal transactions, in both the consensus chain and any domain chain, when a new account is created its default nonce value is set to the current block number (rather than 0 or a any other constant value). This ensures if an account is reaped and then later re-created, in most cases, the new account's nonce is larger than the previous nonce before the account was reaped, which invalidates all previously signed transactions."}),"\n",(0,o.jsx)(n.h2,{id:"compatibility",children:"Compatibility"}),"\n",(0,o.jsx)(n.p,{children:"The new default nonce value mechanism doesn't affect the nonce value of any existing account that is created before this mechanism is activated in the network."}),"\n",(0,o.jsx)(n.p,{children:"For new accounts that are created (or re-created) with this mechanism, its default nonce value will be set to the block number in which the account is created. So when constructing a signed transaction for a new (or potentially reaped) account, tools and custom code should always query the account nonce from on-chain data, instead of assuming a nonce value."})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var a=t(6540);const o={},c=a.createContext(o);function i(e){const n=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(c.Provider,{value:n},e.children)}}}]);