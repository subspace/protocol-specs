"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[484],{9388:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>l,frontMatter:()=>t,metadata:()=>a,toc:()=>r});var i=s(7624),o=s(2172);const t={title:"Cross-Domain Messaging (XDM)",sidebar_position:6,description:"Communication between domains and consensus chain",keywords:["xdm","decex","xcm","challenge period","cross-chain messaging","cross-domain messaging"],last_update:{date:"04/12/2024",author:"Dariia Porechna"}},d=void 0,a={id:"decex/xdm",title:"Cross-Domain Messaging (XDM)",description:"Communication between domains and consensus chain",source:"@site/docs/decex/xdm.md",sourceDirName:"decex",slug:"/decex/xdm",permalink:"/protocol-specs/docs/decex/xdm",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Cross-Domain Messaging (XDM)",sidebar_position:6,description:"Communication between domains and consensus chain",keywords:["xdm","decex","xcm","challenge period","cross-chain messaging","cross-domain messaging"],last_update:{date:"04/12/2024",author:"Dariia Porechna"}},sidebar:"tutorialSidebar",previous:{title:"Fraud Proofs",permalink:"/protocol-specs/docs/decex/fraud_proofs"},next:{title:"Fees and Rewards",permalink:"/protocol-specs/docs/category/fees-and-rewards"}},c={},r=[{value:"Primitives",id:"primitives",level:2},{value:"Chain",id:"chain",level:3},{value:"Domain",id:"domain",level:3},{value:"Trusted third party",id:"trusted-third-party",level:3},{value:"Channel",id:"channel",level:3},{value:"Channel Inbox",id:"channel-inbox",level:3},{value:"Channel Outbox",id:"channel-outbox",level:3},{value:"Channel Response Queue",id:"channel-response-queue",level:3},{value:"Channel Nonce",id:"channel-nonce",level:3},{value:"Message Proof",id:"message-proof",level:3},{value:"Message",id:"message",level:3},{value:"Message Lifecycle",id:"message-lifecycle",level:3},{value:"Relayer Component",id:"relayer-component",level:3},{value:"Fees",id:"fees",level:3},{value:"High-Level Workflow",id:"high-level-workflow",level:2},{value:"Networking",id:"networking",level:2},{value:"Type definitions",id:"type-definitions",level:2},{value:"Functions",id:"functions",level:2},{value:"Chain Allow List",id:"chain-allow-list",level:2},{value:"Initiate Channel",id:"initiate-channel",level:3},{value:"Open Channel",id:"open-channel",level:3},{value:"Close Channel",id:"close-channel",level:3},{value:"Send message",id:"send-message",level:3},{value:"Receive message",id:"receive-message",level:3},{value:"Receive message response",id:"receive-message-response",level:3},{value:"XDM delays",id:"xdm-delays",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"This document describes the current messaging protocol between domains in a trusted code environment (permissioned runtime instantiation). This protocol describes messaging between the consensus chain and any domain and between two domains."}),"\n",(0,i.jsx)(n.h2,{id:"primitives",children:"Primitives"}),"\n",(0,i.jsx)(n.h3,{id:"chain",children:"Chain"}),"\n",(0,i.jsxs)(n.p,{children:["A chain is a blockchain within the Subspace Network. A chain is identified as the Consensus chain or a Domain with a ",(0,i.jsx)(n.code,{children:"DomainID"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"    pub enum ChainId {\n        Consensus,\n        Domain(DomainId),\n    }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"domain",children:"Domain"}),"\n",(0,i.jsx)(n.p,{children:"A Domain is a blockchain with some application modules. These applications act as senders and receivers of the messages using messaging protocol. A unique identifier identifies each application. Domain operators execute transactions bundled by other operators of the same domain when a new block is available."}),"\n",(0,i.jsx)(n.h3,{id:"trusted-third-party",children:"Trusted third party"}),"\n",(0,i.jsxs)(n.p,{children:["A trusted third party from the point of view of the domains is the consensus chain, the farmer network for block production. Domains use consensus chain to submit transaction bundles, verify the Message proofs of ",(0,i.jsx)(n.code,{children:"domain_a"})," on ",(0,i.jsx)(n.code,{children:"domain_b"})," and submit fraud proofs."]}),"\n",(0,i.jsx)(n.h3,{id:"channel",children:"Channel"}),"\n",(0,i.jsxs)(n.p,{children:["A Channel is a bi-directional connection between two domains. Channel connection is established when the ",(0,i.jsx)(n.code,{children:"src_chain_id"})," initiates the channel connection open message, and  ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," responds with either approval or rejection. Once a connection is open, sending messages back and forth is possible. A Channel would be open until a maximum number of messages are sent. This could be configured or defaulted to the maximum possible value of the ",(0,i.jsx)(n.code,{children:"Nonce"})," type."]}),"\n",(0,i.jsx)(n.p,{children:"There is a deposit to open a channel between domains. Deposit should be high enough to discourage and make it economically inefficient to DDOS channel initiation connections between domains."}),"\n",(0,i.jsx)(n.p,{children:"A channel can be closed on either end by the root user. Once closed, the channel will stop sending and receiving any further messages. The Relayer will communicate to the other domain to close the channel and clean up."}),"\n",(0,i.jsxs)(n.p,{children:["A channel can be in one of the following states (",(0,i.jsx)(n.code,{children:"State"}),"):"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Initiated"}),": When a channel is initiated but has not received acknowledgment from the other domain."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Open"}),": When a bi-directional channel is open to relay messages between domains."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Closed"}),": When the channel is closed between the domains and stops receiving and sending new messages to the other domain."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A Channel is defined as follows"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"    type Channel {\n    \t// Unique channel identifier within DomainID namespace\n    \tchannel_id: ChannelID\n    \t// State of the channel\n    \tstate: State\n    \t// Next valid Inbox nonce\n    \tnext_inbox_nonce: Nonce\n    \t// Next valid Outbox nonce\n    \tnext_outbox_nonce: Nonce\n      // Latest outbox message nonce for which response was received from dst_chain.\n    \tlatest_response_received_message_nonce: Nonce\n    \t// Fee Model for this channel\n    \tfee: FeeModel\n    \t// Max number of messages to be in outbox at a given time on both domains.\n    \tmax_outgoing_messages: u32\n    \t/// Owner of the channel\n   \t/// Owner maybe None if the channel was initiated on the other chain.\n\tmaybe_owner: Option<AccountId>,\n    }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"channel-inbox",children:"Channel Inbox"}),"\n",(0,i.jsxs)(n.p,{children:["All the incoming messages to the domain are validated and added to a pool before processing. If specific message arrived earlier than a previous message, it is stored until the previous message(s) is processed in the order of ",(0,i.jsx)(n.code,{children:"Nonce"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"channel-outbox",children:"Channel Outbox"}),"\n",(0,i.jsxs)(n.p,{children:["All messages originated from ",(0,i.jsx)(n.code,{children:"src_chain_id"})," to a ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," will be added to this queue in the runtime state."]}),"\n",(0,i.jsxs)(n.p,{children:["Messages stay in the outbox of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," until the domain block of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," containing the originating extrinsic is out of the challenge period or reached archiving depth (if ",(0,i.jsx)(n.code,{children:"src_chain_id"})," is consensus chain)."]}),"\n",(0,i.jsxs)(n.p,{children:["There is also a notion of back pressure by limiting maximum number of messages queued ",(0,i.jsx)(n.code,{children:"max_outgoing_messages"})," to outbox of ",(0,i.jsx)(n.code,{children:"src_chain_id"}),". So when ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," doesn\u2019t send any message responses, this should throttle the outbox until normal operation. Message is removed from the outbox once the message response is received from the ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"channel-response-queue",children:"Channel Response Queue"}),"\n",(0,i.jsx)(n.p,{children:"All the message responses to the messages in the outbox are validated and added to this queue. The message responses are passed to the application units within the domain. If a response for message arrived earlier that previous message responses, then this response is stored until the previous message responses are delivered."}),"\n",(0,i.jsx)(n.h3,{id:"channel-nonce",children:"Channel Nonce"}),"\n",(0,i.jsx)(n.p,{children:"Channel nonce is used to order messages with in the channel and to avoid replay attacks."}),"\n",(0,i.jsx)(n.p,{children:"A domain maintains 2 nonces for each domain and channel:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Incoming nonce"}),": This nonce is used to order the incoming messages to the domain through the channel from other domain. The nonce starts at 0 and is incremented after each received message."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Outgoing nonce"}),": This nonce is used to order the outgoing messages from this domain to the other domains. The nonce starts at 0 and is incremented after every sent message."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"message-proof",children:"Message Proof"}),"\n",(0,i.jsx)(n.p,{children:"Message proof that can verify the validity of the message from the point-of-view of the consensus chain. Proof combines the storage proofs to validate messages."}),"\n",(0,i.jsx)(n.p,{children:"The proof consists of the following components:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"MMR proof for the state root of the parent consensus block"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"    pub struct MMRProof {\n    \t// consensus block number below archiving depth at which this MMR proof was generated\n    \tconsensus_block_number\t\n    \t// Leaf data that contains consensus storage root \n    \t// storage root is used to verify the `ConfirmedDomainBlocks` storage\n    \tleaf_data\n    \t// merkle proof for this MMR\n    \tproof\n    }\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Proof of the source domain state root and XDM inclusion in runtime"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"    pub struct Proof<BlockNumber, BlockHash, StateRoot> {\n    \t// MMR proof, which provides the state root of consensus hash\n    \tMMRProof\n      \n      /// Storage proof that src chain state_root is confirmed on Consensus chain.\n      /// This is optional when the src_chain is Consensus.\n      pub domain_confirmed_proof: Option<StorageProof>,\n    \n    \t// Storage proof that message is processed on src_chain.\n      pub message_proof: StorageProof,\n    }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"message",children:"Message"}),"\n",(0,i.jsxs)(n.p,{children:["Message encompasses the actual message being sent and metadata about the message itself. MessageID is a unique tuple of (",(0,i.jsx)(n.code,{children:"ChannelID"})," , ",(0,i.jsx)(n.code,{children:"Nonce"}),"). There are two types of Message payloads:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Protocol"})," payload, used by the protocol to open or close, acknowledge channel connection with other domain."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Endpoint"})," payload, used by the protocol to pass messages between endpoint on the ",(0,i.jsx)(n.code,{children:"src"})," and ",(0,i.jsx)(n.code,{children:"dst"})," domains."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"    pub struct Message<Balance> {\n        /// Chain (consensus or domain id) that initiated this message.\n        pub src_chain_id: ChainId,\n        /// Chain (consensus or domain id) this message is intended for.\n        pub dst_chain_id: ChainId,\n        /// ChannelId the message was sent through.\n        pub channel_id: ChannelId,\n        /// Message nonce within the channel.\n        pub nonce: Nonce,\n        /// Payload of the message\n        pub payload: VersionedPayload<Balance>,\n        /// Last delivered message response nonce on src_chain.\n        pub last_delivered_message_response_nonce: Option<Nonce>,\n    }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The response message follows the same structure except the ",(0,i.jsx)(n.code,{children:"payload"})," contains either ",(0,i.jsx)(n.code,{children:"Protocol(Response)"})," or ",(0,i.jsx)(n.code,{children:"Endpoint(Response)"})]}),"\n",(0,i.jsx)(n.h3,{id:"message-lifecycle",children:"Message Lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"Conceptually, a message can be in one of the following states during its lifecycle:"}),"\n",(0,i.jsxs)(n.p,{children:["From the POV of the sender ",(0,i.jsx)(n.code,{children:"src_chain_id"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Outboxed: A message-request is added to the outbox for the relayers to relay message to ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),". It stays in the outbox until the message-response is received."]}),"\n",(0,i.jsx)(n.li,{children:"Delivered: After message-response is received and executed, the message request is cleared from the outbox."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["From the POV of the receiver ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Inboxed: A message-request is added to the inbox for the execution and response. It is not executed until the domain block of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," containing the originating extrinsic is out of the challenge period or reached archiving depth (if ",(0,i.jsx)(n.code,{children:"src_chain_id"})," is consensus chain)."]}),"\n",(0,i.jsx)(n.li,{children:"Cleared: After message-request is executed and message-response is constructed, the message-request is cleared from the inbox and message-response is added to the outbox."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"relayer-component",children:"Relayer Component"}),"\n",(0,i.jsxs)(n.p,{children:["A relayer component relays message from ",(0,i.jsx)(n.code,{children:"src_chain_id"})," to ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),". Domain operators have builtin relayer to relay messages from the domain to other domains and the consensus chain."]}),"\n",(0,i.jsxs)(n.p,{children:["Operators on ",(0,i.jsx)(n.code,{children:"domain_a"})," relay messages originating in ",(0,i.jsx)(n.code,{children:"domain_a"})," to the consensus network and listen for messages destined to ",(0,i.jsx)(n.code,{children:"domain_a"})," from any other domain. Messages are sent through the consensus network where all operators of all domains are present."]}),"\n",(0,i.jsx)(n.p,{children:"The payload for the extrinsic could be a message-request or a message-response."}),"\n",(0,i.jsx)(n.h3,{id:"fees",children:"Fees"}),"\n",(0,i.jsxs)(n.p,{children:["Fees are collected from the sender of the message on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," to pay for relay and execution of their message on both ",(0,i.jsx)(n.code,{children:"src_chain_id"})," and ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," respectively."]}),"\n",(0,i.jsxs)(n.p,{children:["Compute fees are computed based on weights of the exact calls performed on both ",(0,i.jsx)(n.code,{children:"src_chain_id"})," and ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," in total. Collected compute fees for the portion of execution happening on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," is paid to operators of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," and the compute fees for the portion of execution happening ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),". The portion of fees that is to be distributed on ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," is burned on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," when message is added to outbox."]}),"\n",(0,i.jsxs)(n.p,{children:["The burnt fees are subtracted from ",(0,i.jsx)(n.code,{children:"src_chain_id"})," bookkeeping balance (if it\u2019s a domain)."]}),"\n",(0,i.jsxs)(n.p,{children:["The relay fee is split equally among operators on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," and ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," who have submitted the ER that includes the message."]}),"\n",(0,i.jsxs)(n.p,{children:["On the source chain, this reward is distributed when the message gets the response from the ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),". On the ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),", when it receives the next message, it will collect all the messages that are marked delivered on ",(0,i.jsx)(n.code,{children:"src_chain_id"}),", mints the funds, and, distributes the rewards to the relayer pool on ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," for each message."]}),"\n",(0,i.jsxs)(n.p,{children:["The minted fees are added to ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," bookkeeping balance (if it\u2019s a domain)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Outbox Message Fees"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["User ",(0,i.jsx)(n.code,{children:"sender"})," sends a message from ",(0,i.jsx)(n.code,{children:"src_chain_id"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src_chain_id"})," collects ",(0,i.jsx)(n.code,{children:"fees"})," to be paid by ",(0,i.jsx)(n.code,{children:"sender"})," as follows:","\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Compute fee for message execution on ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),". This amount is burnt on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," and minted on ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," later."]}),"\n",(0,i.jsxs)(n.li,{children:["Relay fee for the relayers on ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),". This amount is burnt on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," and minted on ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," later."]}),"\n",(0,i.jsxs)(n.li,{children:["Compute fee for message response execution on ",(0,i.jsx)(n.code,{children:"src_chain_id"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Relay fee for the relayers on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," for relaying the response."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Message is sent to ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Once the response is received from ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),", ",(0,i.jsx)(n.code,{children:"src_chain_id"})," distributes the rewards from ",(0,i.jsx)(n.code,{children:"sender"})," to operators."]}),"\n",(0,i.jsxs)(n.li,{children:["This message nonce is sent to ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," as ",(0,i.jsx)(n.code,{children:"last_delivered_message_response_nonce"})," as an acknowledgement so that it can rewards its operators."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Inbox Message Fees"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dst_chain_id"})," receives a message from ",(0,i.jsx)(n.code,{children:"src_chain_id"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dst_chain_id"})," mints received fees after message validation"]}),"\n",(0,i.jsx)(n.li,{children:"Message is processed and response is sent"}),"\n",(0,i.jsxs)(n.li,{children:["After the delivery acknowledgement from ",(0,i.jsx)(n.code,{children:"src_chain_id"}),", the ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," distributes the fees from ",(0,i.jsx)(n.code,{children:"sender"})," equally to operators who have submitted the ER containing the message extrinsic"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"high-level-workflow",children:"High-Level Workflow"}),"\n",(0,i.jsx)(n.p,{children:"The following describes the generic message from one domain to another. This message could be a protocol message to initiate or close channel connection or an endpoint specific message through an established Channel. In either case, the base message passing remains same:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"User submits a transaction with the message and the required fees. The funds are locked in users account."}),"\n",(0,i.jsxs)(n.li,{children:["Message with an assigned ",(0,i.jsx)(n.code,{children:"nonce"})," is added to the ",(0,i.jsx)(n.code,{children:"outbox"})," of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," with a runtime event issued."]}),"\n",(0,i.jsxs)(n.li,{children:["The operator of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," extracts the message and prepares it to be relayed it to the transaction pool of domain ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),". The relayer needs to construct a storage proof to prove that this message was accepted by domain ",(0,i.jsx)(n.code,{children:"src_chain_id"})," (by proving the message is included in domain ",(0,i.jsx)(n.code,{children:"src_chain_id"})," runtime state), and a state root of domain ",(0,i.jsx)(n.code,{children:"src_chain_id"})," (with respect to a consensus chain state root) so that domain ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," can verify the storage proof."]}),"\n",(0,i.jsxs)(n.li,{children:["Operator of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," waits until the domain block with the ER containing the state root used to construct the storage proof is cleared from the challenge period before gossiping the message."]}),"\n",(0,i.jsxs)(n.li,{children:["Operator of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," gossips the message to the consensus network where all other operators are connected."]}),"\n",(0,i.jsxs)(n.li,{children:["Operators of ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," listen to gossip on consensus and takes the message bound for ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," into its domain transaction pool while ignoring other messages."]}),"\n",(0,i.jsxs)(n.li,{children:["Message proof is validated and if valid added to the inbox of ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Next message nonce is taken from the inbox of ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Message is executed and response is stored."}),"\n",(0,i.jsxs)(n.li,{children:["Operator of ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," waits until the domain block with the message transaction is cleared from the challenge period before gossiping the message response."]}),"\n",(0,i.jsxs)(n.li,{children:["Message response on  ",(0,i.jsx)(n.code,{children:"src_chain_id"})," is validated using storage proofs on the consensus chain."]}),"\n",(0,i.jsxs)(n.li,{children:["Next Message response nonce is submitted to the endpoint and message is removed from the outbox of ",(0,i.jsx)(n.code,{children:"src_chain_id"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["When the ",(0,i.jsx)(n.code,{children:"src_chain_id"})," prepares the next message, it will include the latest message nonce that was successful as part of the payload to notify ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," of message response acknowledgement."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"XDM",src:s(1968).c+"",width:"2297",height:"3002"})}),"\n",(0,i.jsx)(n.h2,{id:"networking",children:"Networking"}),"\n",(0,i.jsx)(n.p,{children:"The messaging protocol uses the consensus network to relay messages, since all the operators of all the domains must also be connected to the consensus network."}),"\n",(0,i.jsxs)(n.p,{children:["This model assumes that there is at least one ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," domain operator to pick the transaction and include in the bundle. If there are no operators to pick the transaction, message could be undelivered until its resubmitted in the network."]}),"\n",(0,i.jsx)(n.h2,{id:"type-definitions",children:"Type definitions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ChainId"}),": enum that identifies whether the chain is Consensus or a Domain with ",(0,i.jsx)(n.code,{children:"DomainId"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DomainID"}),": uniquely identifies a given Domain, ",(0,i.jsx)(n.code,{children:"U32"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ChannelId"}),": uniquely identifies a channel, ",(0,i.jsx)(n.code,{children:"U256"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AccountId"}),": is the public key of the User account"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Nonce"}),": is an incrementing value used for ordering message and avoid replay attacks. We also use nonce as the message ID for a given domain for a given channel, ",(0,i.jsx)(n.code,{children:"U256"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MessageId"}),": uniquely identifies a message, a tuple ",(0,i.jsx)(n.code,{children:"(ChannelId, Nonce)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"EndpointId"})," : represents a unique id of the endpoint on a domain, ",(0,i.jsx)(n.code,{children:"U64"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(n.p,{children:"Detailed description of each function required to be present in the protocol."}),"\n",(0,i.jsx)(n.h2,{id:"chain-allow-list",children:"Chain Allow List"}),"\n",(0,i.jsxs)(n.p,{children:["Consensus chain maintains a ",(0,i.jsx)(n.code,{children:"ChainAllowList"})," to keep track of the authorized domain chains that can establish channels with the Consensus chain. ",(0,i.jsx)(n.code,{children:"ChainAllowList"})," can be defined at Genesis and can be updated later by the sudo account adding or removing chains."]}),"\n",(0,i.jsxs)(n.p,{children:["When a Consensus chain receives an ",(0,i.jsx)(n.code,{children:"initiate_channel"})," XDM to open the channel, if the ",(0,i.jsx)(n.code,{children:"src_chain"})," is in the allowlist, then channel is opened else XDM is rejected.\nPractically, this means that a newly initialized domain chain needs to be approved by governance and added to the Consensus chain's ",(0,i.jsx)(n.code,{children:"ChainAllowList"})," before it can initiate a channel with the Consensus chain."]}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, each domain chain maintains its own ",(0,i.jsx)(n.code,{children:"DomainChainAllowList"})," to keep track of the authorized domains it can establish channels with. This allows the domains to control and restrict which other domains they want to interact with. Updating domain-specific lists is done within a domain by the domain's sudo or governance, without consensus chain approval."]}),"\n",(0,i.jsx)(n.h3,{id:"initiate-channel",children:"Initiate Channel"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Channel ",(0,i.jsx)(n.code,{children:"initiate_channel"})," transaction is sent by the root user of the domain."]}),"\n",(0,i.jsxs)(n.li,{children:["If the domain is in the allow list, the next available ",(0,i.jsx)(n.code,{children:"ChannelID"})," is assigned to the new channel."]}),"\n",(0,i.jsxs)(n.li,{children:["If no Channel exits, Channel is created and set to ",(0,i.jsx)(n.code,{children:"Initiated"})," status and cannot accept or receive any messages yet."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Protocol"})," payload message to open the channel is added to the ",(0,i.jsx)(n.code,{children:"src_chain_id"})," domain outbox with nonce ",(0,i.jsx)(n.code,{children:"0"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"open-channel",children:"Open Channel"}),"\n",(0,i.jsxs)(n.p,{children:["Before sending any messages, domain needs to have an channel open with the ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Channel is initiated by ",(0,i.jsx)(n.code,{children:"src_chain_id"})," as described in ",(0,i.jsx)(n.a,{href:"#initiate-channel",children:"Initiate Channel"})]}),"\n",(0,i.jsxs)(n.li,{children:["Operator on ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," receives a message with the corresponding ",(0,i.jsx)(n.code,{children:"Protocol"})," ",(0,i.jsx)(n.code,{children:"ChannelOpen"})," payload and ",(0,i.jsx)(n.code,{children:"nonce=0"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Channel status is set to ",(0,i.jsx)(n.code,{children:"Open"})," and a corresponding event is issued"]}),"\n",(0,i.jsxs)(n.li,{children:["Operators on ",(0,i.jsx)(n.code,{children:"dst_domain"})," submits the transaction with message response to ",(0,i.jsx)(n.code,{children:"src_chain_id"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src_domain"})," moves the channel state to ",(0,i.jsx)(n.code,{children:"Open"})," and starts accepting messages to be sent over channel"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"close-channel",children:"Close Channel"}),"\n",(0,i.jsx)(n.p,{children:"Any domain of either end of the open channel can close the channel:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Channel close transaction is sent by the root user."}),"\n",(0,i.jsxs)(n.li,{children:["Channel state is set to ",(0,i.jsx)(n.code,{children:"Closed"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Protocol"})," payload message to close channel is added to the ",(0,i.jsx)(n.code,{children:"src_chain_id"})," outbox"]}),"\n",(0,i.jsxs)(n.li,{children:["Operator on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," gossips the message"]}),"\n",(0,i.jsxs)(n.li,{children:["Operator on ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," receives a message with the corresponding ",(0,i.jsx)(n.code,{children:"Protocol"})," ",(0,i.jsx)(n.code,{children:"ChannelClose"})," payload."]}),"\n",(0,i.jsxs)(n.li,{children:["Channel close response is submitted to ",(0,i.jsx)(n.code,{children:"src_chain_id"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"send-message",children:"Send message"}),"\n",(0,i.jsxs)(n.p,{children:["When user wants to send message from endpoint on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," to an endpoint on ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),"  with open channel to ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),"."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["User sends a transaction that results in a message to an endpoint on ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Transaction is included in the runtime state of ",(0,i.jsx)(n.code,{children:"src_chain_id"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["A next incrementing ",(0,i.jsx)(n.code,{children:"nonce"})," > 0 (0 is always reserved for Channel open message) is assigned to the message bound to ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Next message nonce storage is updated."}),"\n",(0,i.jsxs)(n.li,{children:["Execution layer stores the message in the ",(0,i.jsx)(n.code,{children:"Outbox"})," and emits ",(0,i.jsx)(n.code,{children:"new_message"})," event."]}),"\n",(0,i.jsxs)(n.li,{children:["Operator of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," waits until the domain block with the ER containing the state root used to construct the storage proof is cleared from the challenge period before gossiping the message (or below archiving depth if ",(0,i.jsx)(n.code,{children:"src_chain_id"})," is consensus chain)."]}),"\n",(0,i.jsxs)(n.li,{children:["The operator of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," extracts the message and prepares it to be relayed it to the transaction pool of domain ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),". The relayer needs to construct a storage proof to prove that this message was accepted by domain ",(0,i.jsx)(n.code,{children:"src_chain_id"})," (by proving the message is included in domain ",(0,i.jsx)(n.code,{children:"src_chain_id"})," runtime state), and a state root of domain ",(0,i.jsx)(n.code,{children:"src_chain_id"})," (with respect to a parent consensus chain state root via MMR) so that domain ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," can verify the storage proof."]}),"\n",(0,i.jsxs)(n.li,{children:["Operator of ",(0,i.jsx)(n.code,{children:"src_chain_id"})," gossips the message to the consensus network where all other operators are connected."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"receive-message",children:"Receive message"}),"\n",(0,i.jsxs)(n.p,{children:["When a relayer from ",(0,i.jsx)(n.code,{children:"src_chain_id"})," submits the message to the inbox of the ",(0,i.jsx)(n.code,{children:"dst_chain_id"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dst_chain_id"})," verifies the message by verifying the storage proof from the point of view of the consensus chain as follows:","\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Check if the MMR proof is constructed at a finalized consensus block to ensure the ",(0,i.jsx)(n.code,{children:"MMR::verify_proof"})," result is deterministic regardless of the consensus chain fork."]}),"\n",(0,i.jsxs)(n.li,{children:["Verifies MMR proof using consensus chain ",(0,i.jsx)(n.code,{children:"MMR::verify_proof"})," function to extract the MMR leaf data and the corresponding state root of consensus chain."]}),"\n",(0,i.jsxs)(n.li,{children:["Using ",(0,i.jsx)(n.code,{children:"consensus_chain_state_root"}),", ",(0,i.jsx)(n.code,{children:"domain_confirmed_proof"})," is verified and associated domain\u2019s ",(0,i.jsx)(n.code,{children:"state_root"})," is extracted from ",(0,i.jsx)(n.code,{children:"DomainBlockInfo"})]}),"\n",(0,i.jsxs)(n.li,{children:["Using ",(0,i.jsx)(n.code,{children:"domain_state_root"}),", ",(0,i.jsx)(n.code,{children:"message_proof"})," is verified and actual XDM is extracted from the storage proof."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dst_chain_id"})," adds the message to its inbox."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dst_chain_id"})," listens for next message to process from the inbox in the nonce order."]}),"\n",(0,i.jsx)(n.li,{children:"Message is passed to the endpoint and eventually executed and response is stored for that message."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dst_chain_id"})," takes the latest delivered message nonce on ",(0,i.jsx)(n.code,{children:"src_chain_id"})," and distributes the rewards to the operators and deletes any stored state pertaining to any message with nonce below the confirmed nonce."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"receive-message-response",children:"Receive message response"}),"\n",(0,i.jsxs)(n.p,{children:["Relayer from the ",(0,i.jsx)(n.code,{children:"dst_chain_id"})," will submit the message response to the ",(0,i.jsx)(n.code,{children:"src_chain_id"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src_chain_id"})," verifies the message response and adds it to the message response queue."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src_chain_id"})," listens for next message response and submits the response to the caller module on the ",(0,i.jsx)(n.code,{children:"src_domain"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src_chain_id"})," marks the message nonce as the last confirmed message which is included in the next message bound to ",(0,i.jsx)(n.code,{children:"dst_chain_id"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src_chain_id"})," then deletes the state pertaining to the original message from the runtime."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"xdm-delays",children:"XDM delays"}),"\n",(0,i.jsx)(n.p,{children:"Since XDM is inherently a request response protocol it may require a response in some cases."}),"\n",(0,i.jsxs)(n.p,{children:["The use cases such as transfer or sending some payload where response is just an acknowledgement, it is generally ignored. With that in mind, the following table will give the time to send a message from ",(0,i.jsx)(n.code,{children:"Any chain -> Any chain"})]}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"K = Archiving depth"})," (currently 100 consensus blocks) and ",(0,i.jsx)(n.code,{children:"D = Domain challenge period"})," (currently 14400 domain blocks)"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Domain \u2192 Any chain"}),(0,i.jsx)(n.th,{children:"Consensus \u2192 Any domain"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"K + D"}),(0,i.jsx)(n.td,{children:"K"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"For XDM where response is required from, the following table captures the time in blocks"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Domain \u2192 Consensus \u2192 Domain"}),(0,i.jsx)(n.th,{children:"Consensus \u2192 Domain \u2192 Consensus"}),(0,i.jsx)(n.th,{children:"Domain A \u2192 Domain B \u2192 Domain A"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2 * K + D"}),(0,i.jsx)(n.td,{children:"D + 2 * K"}),(0,i.jsx)(n.td,{children:"2 * K + 2 * D"})]})})]})]})}function l(e={}){const{wrapper:n}={...(0,o.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1968:(e,n,s)=>{s.d(n,{c:()=>i});const i=s.p+"assets/images/XDM-62b55026f65238ef0bd4291e43b4819a.png"},2172:(e,n,s)=>{s.d(n,{I:()=>a,M:()=>d});var i=s(1504);const o={},t=i.createContext(o);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);