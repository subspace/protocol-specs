"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[792],{4320:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>d,metadata:()=>r,toc:()=>a});var s=i(7624),o=i(2172),t=i(4916);const d={title:"Bundles and Domain Blocks",sidebar_position:3,description:"Structure of bundles and domain blocks.",keywords:["execution","decex","bundle"],last_update:{date:"10/03/2024",author:"Dariia Porechna"}},l=void 0,r={id:"decex/bundles_blocks",title:"Bundles and Domain Blocks",description:"Structure of bundles and domain blocks.",source:"@site/docs/decex/bundles_blocks.md",sourceDirName:"decex",slug:"/decex/bundles_blocks",permalink:"/protocol-specs/docs/decex/bundles_blocks",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Bundles and Domain Blocks",sidebar_position:3,description:"Structure of bundles and domain blocks.",keywords:["execution","decex","bundle"],last_update:{date:"10/03/2024",author:"Dariia Porechna"}},sidebar:"tutorialSidebar",previous:{title:"Domains Interfaces",permalink:"/protocol-specs/docs/decex/interfaces"},next:{title:"Workflow",permalink:"/protocol-specs/docs/decex/workflow"}},c={},a=[{value:"Bundles",id:"bundles",level:2},{value:"Bundle Header",id:"bundle-header",level:3},{value:"Bundle Body",id:"bundle-body",level:3},{value:"Bundle Limits",id:"bundle-limits",level:3},{value:"Domain Blocks",id:"domain-blocks",level:2},{value:"Execution Receipt",id:"execution-receipt",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,o.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"bundles",children:"Bundles"}),"\n",(0,s.jsx)(n.p,{children:"Operators produce bundles, which add new extrinsics to the execution inbox, and output the execution result of all prior bundles. Bundles are produced probabilistically based on the stake-weighted operator VRF election. The bundle consists of a header and a body."}),"\n",(0,s.jsx)(n.h3,{id:"bundle-header",children:"Bundle Header"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ProofOfElection"}),": the proof for the stake-weighted VRF election.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"domain_id"}),": the index of the domain for this bundle. Must exist within the ",(0,s.jsx)(n.code,{children:"DomainRegistry"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"operator_id"}),": the id for this operator in the registry. We do not need to include the public key since it already resides within the operator registry."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"slot_number"}),": the time slot number for the randomness beacon."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"proof_of_time"}),": random output for that slot from the ",(0,s.jsx)(n.a,{href:"/protocol-specs/docs/consensus/proof_of_time",children:"Proof-of-Time"})," beacon."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"vrf_signature"}),": the signature of the slot randomness using the operator\u2019s private key. Used to verify the VRF election based on the operator's proportion of stake for this domain."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ExecutionReceipt"})," of the last domain block executed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"estimated_bundle_weight"}),": the total (estimated) weight of all extrinsics in the bundle. Used to prevent overloading the bundle with compute."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bundle_extrinsics_root"}),": the Merkle root of all new extrinsics included in this bundle, will be added to the ",(0,s.jsx)(n.code,{children:"execution_inbox"})," for this domain must be included in the next domain block for it to be valid."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"signature"}),": the Schnorr signature of the hash of the bundle header."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"bundle-body",children:"Bundle Body"}),"\n",(0,s.jsx)(n.p,{children:"The bundle body is largely an \u201copaque blob\u201d for consensus nodes. They only check to ensure the total size, weight, and Merkle roots are correct, but they should not need to interpret the semantics of individual transactions."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"extrinsics"}),"\nan ordered list of all new extrinsics being proposed by this operator for the next domain block. All the extrinsic is verified against the last domain block according to the ",(0,s.jsx)(n.code,{children:"ExecutionReceipt"})," in the bundle header."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"bundle-limits",children:"Bundle Limits"}),"\n",(0,s.jsxs)(n.p,{children:["The size of bundle body in bytes and it's ",(0,s.jsx)(n.code,{children:"estimated_bundle_weight"})," are limited by the ",(0,s.jsx)(n.code,{children:"max_bundle_size"})," and ",(0,s.jsx)(n.code,{children:"max_bundle_weight"})," ",(0,s.jsx)(n.a,{href:"/protocol-specs/docs/decex/workflow#domain-genesis-config",children:"domain configuration"})," items as well as the consensus block size and weight limits based on the expected number of bundles ",(0,s.jsx)(n.code,{children:"bundle_slot_probability/SLOT_PROBABILITY"})," in a single block."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"max_bundle_size"})," item should be defined such that the average bundle size by expected number of bundles fits within the consensus block size limit.\nThe ",(0,s.jsx)(n.code,{children:"max_bundle_weight"})," item should be defined based on hardware expectations for this domain. The operators would on average have to handle execution of domain blocks with ",(0,s.jsx)(n.code,{children:"bundle_slot_probability/SLOT_PROBABILITY"})," bundles."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, given the consensus ",(0,s.jsx)(n.code,{children:"SLOT_PROBABILITY=1/6"})," if ",(0,s.jsx)(n.code,{children:"bundle_slot_probability = 1"}),", each domain block is expected to have 6 bundles on average with 95.74% of blocks having 11 or fewer bundles. In this case, ",(0,s.jsx)(n.code,{children:"max_bundle_weight"})," should be defined so that the operator can execute the total weight of 6 full bundles within the target block weight limit of 1500 ms. Similarly, ",(0,s.jsx)(n.code,{children:"max_bundle_size"})," should be defined to fit 6 full bundles within the consensus block size limit of 3.75 MiB for normal extrinsics. The domain config would then have:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bundle_slot_probability = 1"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"max_bundle_weight = 250 ms"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"max_bundle_size = 655 360 bytes"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The weight limit of any individual extrinsic is equal to ",(0,s.jsx)(n.code,{children:"max_bundle_weight"})," as even the biggest extrinsic should fit within the bundle to be included by operators."]}),"\n",(0,s.jsxs)(n.p,{children:["The creators of a domain may set up different limits based on their execution needs, as long as they are within the system limits defined in the ",(0,s.jsx)(n.a,{href:"/protocol-specs/docs/decex/workflow#domain-genesis-config",children:"Domain Genesis Config"})," section. For example, a domain may choose a higher ",(0,s.jsx)(n.code,{children:"max_bundle_weight"})," and lower ",(0,s.jsx)(n.code,{children:"bundle_slot_probability"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"domain-blocks",children:"Domain Blocks"}),"\n",(0,s.jsxs)(n.p,{children:["Domain block follows the standard ",(0,s.jsx)(n.a,{href:"https://github.com/paritytech/substrate/blob/689da495a0c0c0c2466fe90a9ea187ce56760f2d/primitives/runtime/src/generic/block.rs#L82",children:"Substrate block format"}),". It consists of a Header and a list of extrinsics that are compiled from the bundles contained within the consensus block."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/paritytech/substrate/blob/689da495a0c0c0c2466fe90a9ea187ce56760f2d/primitives/runtime/src/generic/header.rs#L39",children:"Header"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.code,{children:"parent_hash"})})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.code,{children:"number"})})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.code,{children:"state_root"})})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.code,{children:"extrinsics_root"})})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.c,{title:"Note",children:(0,s.jsxs)(n.p,{children:["Substrate header also contains a ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.code,{children:"digest"})})," field, but it is usually unused for the domain block. It was used to feed some consensus chain data into the domain block before but will likely not be used going forward if it causes a challenge for fraud proofs."]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Extrinsics"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"execution-receipt",children:"Execution Receipt"}),"\n",(0,s.jsx)(n.p,{children:"Execution Receipt (ER) is a deterministic receipt for the execution of a domain block. It provides a way to prove or disprove valid execution of the ordered set of extrinsics in the domain block body."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"domain_block_number"}),": the index of the current domain block that forms the basis of this ER."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"domain_block_hash"}),": the block hash corresponding to ",(0,s.jsx)(n.code,{children:"domain_block_number"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"domain_block_extrinsics_root"}),": extrinsics root field of the header of the domain block referenced by this ER."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"parent_domain_block_receipt_hash"}),": a pointer to the hash of the ER for the last domain block. The parent must have already been included in this domain\u2019s blocktree by the consensus chain for this bundle to be valid. Note that this does not have to be the tip of the domain blocktree (on the consensus chain), as this bundle could be confirming an existing tip or forking away from a fraudulent branch."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"consensus_block_number"}),": a pointer to the consensus block index which contains all of the bundles that were used to derive and order all extrinsics executed by the current domain block for this ER."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"consensus_block_hash"}),": a pointer to the consensus block hash which contains all of the bundles that were used to derive and order all extrinsics executed by the current domain block for this ER."]}),"\n",(0,s.jsx)(t.c,{title:"Note",children:(0,s.jsx)(n.p,{children:"Consensus block number alone is insufficient, since their could be honest forks of the consensus chain."})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"inboxed_bundles"}),": list of all bundles included in and excluded from execution by this domain block, contains a list of hashes and invalidity reasons for bundles ",(0,s.jsx)(n.code,{children:"(Valid or Invalid(InvalidBundleType), extrinsics_root)"}),". The bundles marked ",(0,s.jsx)(n.code,{children:"Invalid"})," were initially included in the consensus block, but later deemed invalid and excluded from execution."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"bundle_extrinsics_roots"}),": all ",(0,s.jsx)(n.code,{children:"extrinsic_root"}),"s for all bundles being executed by this block. Used to ensure these are contained within the state of the ",(0,s.jsx)(n.code,{children:"execution_inbox"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"final_state_root"}),": the final state root for the current domain block reflected by this ER. Used for verifying storage proofs for domains."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"execution_trace"}),": an ordered list of the post-state root values after each transaction in the current domain block was executed, as computed locally by this operator."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"execution_trace_root"}),": the Merkle root of the execution trace for the current domain block. Used for verifying fraud proofs."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"block_fees"}),": all SSC fees for this ER to be shared across operators. These include the total execution and storage fees for executing the previous domain block and fees for relaying the XDM messages to other domains."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"transfers"}),": amounts transferred via XDM to/from other domains or consensus chain or otherwise burned/minted on this domain"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"transfers_in"})," into the current domain"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"transfers_out"})," out of the current domain"]}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},4916:(e,n,i)=>{i.d(n,{c:()=>t});var s=i(1504),o=i(7624);const t=e=>{let{title:n,children:i}=e;const[t,d]=(0,s.useState)(!1);return(0,o.jsxs)("div",{className:"collapsible",children:[(0,o.jsxs)("button",{className:"collapsible-toggle",onClick:()=>d(!t),children:[t?"\u25bc":"\u25ba"," ",n]}),(0,o.jsx)("div",{className:"collapsible-content "+(t?"open":""),children:t&&i})]})}},2172:(e,n,i)=>{i.d(n,{I:()=>l,M:()=>d});var s=i(1504);const o={},t=s.createContext(o);function d(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);